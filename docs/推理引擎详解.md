# 推理引擎详解

本文档详细解析 `src/core/reasoner.py` 中 `RuleReasoner` 类的实现逻辑。

## 1. 概述

推理引擎是专家系统的核心组件，基于**产生式规则**实现，支持两种推理模式：

- **正向推理（Forward Chaining）**：从已知事实出发，逐步应用规则推导新结论
- **反向推理（Backward Chaining）**：从目标结论出发，反向寻找需要满足的条件

## 2. 数据结构

### 2.1 核心存储结构

```python
_lines_list: list[tuple[list[int], int]]  # 规则列表 [(前提id列表, 结论id), ...]
_node_list: list[dict]                     # 节点列表 [{prelines_id: [], anslines_id: []}, ...]
_name_id_map: dict[str, int]               # 名称 → ID 映射
_id_name_map: dict[int, str]               # ID → 名称 映射
```

### 2.2 规则表示

每条规则存储为 `(前提id列表, 结论id)` 的元组：

```
规则: ["毛发"] → "哺乳动物"
存储: ([0], 1)  # 假设 "毛发"=0, "哺乳动物"=1
```

### 2.3 节点结构

每个节点（事实/结论）维护两个引用列表：

```python
{
    "prelines_id": [...]  # 能推导出该节点的规则ID列表（作为结论）
    "anslines_id": [...]  # 该节点参与的规则ID列表（作为前提）
}
```

**示意图：**

```
规则0: [毛发] → 哺乳动物
规则1: [哺乳动物, 肉食动物] → 老虎

节点"毛发":      prelines_id=[], anslines_id=[0]
节点"哺乳动物":  prelines_id=[0], anslines_id=[1]
节点"肉食动物":  prelines_id=[], anslines_id=[1]
节点"老虎":      prelines_id=[1], anslines_id=[]
```

### 2.4 推理状态

```python
_known_set: set[int]      # 已知为真的事实ID集合
_false_set: set[int]      # 已知为假的事实ID集合（反向推理用）
_reasoner_path: list[int] # 推理路径（经过的规则ID序列）
```

## 3. 正向推理算法

### 3.1 算法流程

```
输入: 已知事实集合 _known_set
输出: 最终结论列表, 推理路径

1. 初始化栈 stack = 已知事实列表
2. while 栈不为空:
   a. 弹出当前节点 now_id
   b. 如果该节点没有后续规则 → 加入结论列表
   c. 遍历该节点参与的所有规则:
      - 如果结论已知 → 跳过
      - 检查所有前提是否都在 _known_set 中
      - 如果满足 → 结论加入 _known_set，压入栈
3. 返回结论列表和推理路径
```

### 3.2 代码解析

```python
def find(self) -> tuple[list[str], list[int]]:
    result: list[str] = []
    stack = list(self._known_set)  # 从已知事实开始

    while stack:
        now_id = stack.pop()
        now_node = self._node_list[now_id]

        # 没有后续规则 = 推理终点 = 最终结论
        if not now_node["anslines_id"]:
            result.append(self._get_id_name(now_id))
            continue

        # 遍历该节点作为前提的所有规则
        for line_id in now_node["anslines_id"]:
            pres_id, ans_id = self._lines_list[line_id]

            if ans_id in self._known_set:  # 结论已知，跳过
                continue

            # 检查所有前提是否满足
            can_get = all(pre_id in self._known_set for pre_id in pres_id)

            if can_get:
                self._reasoner_path.append(line_id)  # 记录路径
                self._known_set.add(ans_id)          # 新结论加入已知集合
                stack.append(ans_id)                 # 继续推理

    return result, self._reasoner_path.copy()
```

### 3.3 示例

```
规则: [毛发] → 哺乳动物, [哺乳动物, 吃肉] → 肉食动物, [肉食动物, 黄褐色] → 老虎
已知: [毛发, 吃肉, 黄褐色]

推理过程:
1. 栈: [毛发, 吃肉, 黄褐色]
2. 弹出"黄褐色" → 无法单独触发规则
3. 弹出"吃肉" → 无法单独触发规则
4. 弹出"毛发" → 触发规则0 → 得到"哺乳动物"
5. 弹出"哺乳动物" → 与"吃肉"一起触发规则1 → 得到"肉食动物"
6. 弹出"肉食动物" → 与"黄褐色"一起触发规则2 → 得到"老虎"
7. 弹出"老虎" → 无后续规则 → 加入结论

结论: ["老虎"]
```

## 4. 反向推理算法

### 4.1 算法流程

反向推理采用**栈式深度优先搜索**，支持交互式询问用户。

```
输入: 目标结论 target
输出: (状态码, 数据, 推理路径)
  - 状态0: 成功，数据为目标名
  - 状态1: 失败，数据为空
  - 状态2: 需询问用户，数据为待确认事实列表

1. 初始化栈 = [{u: 目标ID, rule_idx: 0}]
2. while 栈不为空:
   a. 取栈顶 {u, rule_idx}
   b. 如果 u 已知为真 → 弹出，继续
   c. 如果 u 已知为假 → 弹出，继续
   d. 获取能推导 u 的规则列表
   e. 如果所有规则都试过了 → 标记 u 为假，弹出
   f. 取第 rule_idx 条规则，检查其前提:
      - 前提已知为假 → 规则不可行，rule_idx++
      - 前提已知为真 → 跳过
      - 前提无推导规则 → 需询问用户
      - 前提有推导规则 → 设为子目标，压栈
   g. 如果所有前提满足 → u 成立，弹出
3. 检查目标是否在 _known_set 中
```

### 4.2 栈结构

```python
_bw_stack: list[dict]  # [{u: 节点ID, rule_idx: 当前尝试的规则索引}, ...]
```

每个栈帧记录：

- `u`: 当前要证明的目标节点
- `rule_idx`: 当前尝试的是第几条规则（用于回溯）

### 4.3 代码解析

```python
def step_backward(self, target: str) -> tuple[int, list[str], list[int]]:
    target_id = self._get_name_id(target)

    # 目标改变时重置栈
    if self._in_backward != target_id:
        self._bw_stack.clear()
        self._bw_stack.append({"u": target_id, "rule_idx": 0})
        self._in_backward = target_id

    while self._bw_stack:
        top = self._bw_stack[-1]
        u = top["u"]

        # 已知为真/假，直接弹出
        if u in self._known_set or u in self._false_set:
            self._bw_stack.pop()
            continue

        rules = self._node_list[u]["prelines_id"]

        # 所有规则都试过了，标记为假
        if top["rule_idx"] >= len(rules):
            self._false_set.add(u)
            self._bw_stack.pop()
            continue

        line_id = rules[top["rule_idx"]]
        pres_id, _ = self._lines_list[line_id]

        rule_possible = True
        subgoal = None
        to_ask = []

        for pre_id in pres_id:
            if pre_id in self._false_set:      # 前提为假 → 规则不可行
                rule_possible = False
                break
            if pre_id in self._known_set:      # 前提为真 → 跳过
                continue
            if not self._node_list[pre_id]["prelines_id"]:  # 无推导规则 → 询问
                to_ask.append(self._get_id_name(pre_id))
            else:                              # 有推导规则 → 子目标
                if subgoal is None:
                    subgoal = pre_id

        if not rule_possible:                  # 规则不可行，尝试下一条
            top["rule_idx"] += 1
            continue

        if subgoal is not None:                # 有子目标，压栈
            self._bw_stack.append({"u": subgoal, "rule_idx": 0})
            continue

        if to_ask:                             # 需要询问用户
            return 2, to_ask, self._reasoner_path.copy()

        # 所有前提满足，目标成立
        self._known_set.add(u)
        self._reasoner_path.append(line_id)
        self._bw_stack.pop()

    # 推理结束
    if target_id in self._known_set:
        return 0, [target], self._reasoner_path.copy()
    return 1, [], self._reasoner_path.copy()
```

### 4.4 示例

```
规则: [毛发] → 哺乳动物, [哺乳动物, 吃肉] → 肉食动物
目标: 肉食动物
已知: []

推理过程:
1. 栈: [{u: 肉食动物, rule_idx: 0}]
2. 检查规则1: [哺乳动物, 吃肉] → 肉食动物
   - 哺乳动物: 有推导规则 → 设为子目标
3. 栈: [{u: 肉食动物, rule_idx: 0}, {u: 哺乳动物, rule_idx: 0}]
4. 检查规则0: [毛发] → 哺乳动物
   - 毛发: 无推导规则 → 询问用户
5. 返回 (2, ["毛发"], [])

用户确认"毛发"为真后继续:
6. 毛发 ∈ known_set → 规则0满足 → 哺乳动物成立
7. 回到肉食动物，检查"吃肉" → 询问用户
8. 返回 (2, ["吃肉"], [0])

用户确认"吃肉"为真后继续:
9. 规则1满足 → 肉食动物成立
10. 返回 (0, ["肉食动物"], [0, 1])
```

## 5. 辅助方法

| 方法                | 功能                     |
| ------------------- | ------------------------ |
| `reset(rules)`      | 重置推理器，加载新规则集 |
| `add_known(known)`  | 添加已知为真的事实       |
| `clear_known()`     | 清空已知事实             |
| `add_false(falses)` | 添加已知为假的事实       |
| `clear_false()`     | 清空假事实               |

## 6. 设计特点

1. **ID 映射机制**：字符串名称与整数 ID 双向映射，提高查找效率
2. **双向索引**：节点同时记录"作为前提"和"作为结论"的规则，支持双向遍历
3. **增量推理**：反向推理支持中断和恢复，适合交互式场景
4. **路径记录**：完整记录推理经过的规则，支持可视化展示

---

# C++ 版推理引擎详解

本节解析 `src/core/Rule_reasoner.cpy.cpp` 中的 C++ 实现，与 Python 版逻辑一致，但使用 C++ 数据结构。

## 1. 数据结构对比

| Python                        | C++                          | 说明         |
| ----------------------------- | ---------------------------- | ------------ |
| `list[tuple[list[int], int]]` | `vector<line>`               | 规则列表     |
| `list[dict]`                  | `vector<node>`               | 节点列表     |
| `dict[str, int]`              | `unordered_map<string, int>` | 名称 →ID     |
| `dict[int, str]`              | `unordered_map<int, string>` | ID→ 名称     |
| `set[int]`                    | `unordered_set<int>`         | 已知事实集合 |
| `list[dict]`                  | `stack<BackwardFrame>`       | 反向推理栈   |

### 1.1 规则结构体 `line`

```cpp
struct line {
    vector<int> pres_id;  // 前提ID列表
    int ans_id;           // 结论ID
    line(const vector<int> &_pres_id, const int &_ans_id)
        : pres_id(_pres_id), ans_id(_ans_id) {}
};
```

### 1.2 节点结构体 `node`

```cpp
struct node {
    vector<int> prelines_id;  // 能推导出该节点的规则ID（作为结论）
    vector<int> anslines_id;  // 该节点参与的规则ID（作为前提）
};
```

### 1.3 反向推理栈帧 `BackwardFrame`

```cpp
struct BackwardFrame {
    int u;         // 当前要证明的目标节点ID
    int rule_idx;  // 当前尝试的规则索引
};
```

## 2. 核心方法实现

### 2.1 添加规则 `add_rule`

```cpp
void Rule_reasoner::add_rule(const vector<string> &pres, const string &ans) {
    vector<int> pres_id;
    for (const string &pre : pres) {
        pres_id.push_back(get_name_id(pre));  // 获取或创建前提ID
    }
    int ans_id = get_name_id(ans);            // 获取或创建结论ID
    line newline(pres_id, ans_id);
    int line_id = get_line_id(newline);       // 插入规则，获取规则ID

    // 更新节点的规则引用
    for (const int &pre_id : pres_id) {
        node_list[pre_id].anslines_id.push_back(line_id);  // 前提节点记录该规则
    }
    node_list[ans_id].prelines_id.push_back(line_id);      // 结论节点记录该规则
}
```

### 2.2 正向推理 `find`

```cpp
pair<vector<string>, vector<int>> Rule_reasoner::find() {
    vector<string> result;
    reasoner_path.clear();
    stack<int> s;

    // 初始化：将所有已知事实压栈
    for (const int &id : known_set) {
        s.push(id);
    }

    while (!s.empty()) {
        int now_id = s.top();
        s.pop();
        node &now_node = node_list[now_id];

        // 没有后续规则 = 推理终点
        if (now_node.anslines_id.empty()) {
            result.push_back(get_id_name(now_id));
            continue;
        }

        // 遍历该节点作为前提的所有规则
        for (const int &line_id : now_node.anslines_id) {
            line &now_line = lines_list[line_id];

            if (known_set.count(now_line.ans_id))  // 结论已知，跳过
                continue;

            // 检查所有前提是否满足
            bool can_get = true;
            for (const int &pre_id : now_line.pres_id) {
                if (!known_set.count(pre_id)) {
                    can_get = false;
                    break;
                }
            }

            if (can_get) {
                reasoner_path.push_back(line_id);      // 记录路径
                known_set.insert(now_line.ans_id);    // 新结论加入已知集合
                s.push(now_line.ans_id);              // 继续推理
            }
        }
    }

    return {result, reasoner_path};
}
```

### 2.3 反向推理 `step_backward`

```cpp
tuple<int, vector<string>, vector<int>> Rule_reasoner::step_backward(string target_name) {
    int target_id = get_name_id(target_name);
    reasoner_path.clear();
    reasoner_set.clear();

    // 目标改变时重置栈
    if (in_backward != target_id) {
        while (!bw_stack.empty()) bw_stack.pop();
        bw_stack.push({target_id, 0});
        in_backward = target_id;
    }

    while (!bw_stack.empty()) {
        BackwardFrame &top = bw_stack.top();
        int u = top.u;

        // 已知为真/假，直接弹出
        if (known_set.count(u)) { bw_stack.pop(); continue; }
        if (false_set.count(u)) { bw_stack.pop(); continue; }

        vector<int> &rules = node_list[u].prelines_id;

        // 所有规则都试过了，标记为假
        if (top.rule_idx >= (int)(rules.size())) {
            false_set.insert(u);
            bw_stack.pop();
            continue;
        }

        int line_id = rules[top.rule_idx];
        line &l = lines_list[line_id];

        bool rule_possible = true;
        int subgoal = -1;
        vector<string> to_ask;

        for (const int &pre_id : l.pres_id) {
            if (false_set.count(pre_id)) {        // 前提为假 → 规则不可行
                rule_possible = false;
                break;
            }
            if (known_set.count(pre_id))          // 前提为真 → 跳过
                continue;

            if (node_list[pre_id].prelines_id.empty()) {  // 无推导规则 → 询问
                to_ask.push_back(get_id_name(pre_id));
            } else {                              // 有推导规则 → 子目标
                if (subgoal == -1) subgoal = pre_id;
            }
        }

        if (!rule_possible) {                     // 规则不可行，尝试下一条
            top.rule_idx++;
            continue;
        }

        if (subgoal != -1) {                      // 有子目标，压栈
            bw_stack.push({subgoal, 0});
            continue;
        }

        if (!to_ask.empty()) {                    // 需要询问用户
            return {2, to_ask, reasoner_path};
        }

        // 所有前提满足，目标成立
        known_set.insert(u);
        if (reasoner_set.count(line_id) == 0) {
            reasoner_path.push_back(line_id);
            reasoner_set.insert(line_id);
        }
        bw_stack.pop();
    }

    in_backward = -1;
    if (known_set.count(target_id))
        return {0, {target_name}, reasoner_path};
    return {1, {}, reasoner_path};
}
```

## 3. C++ vs Python 实现差异

| 方面     | C++                          | Python         |
| -------- | ---------------------------- | -------------- |
| 性能     | 更快（编译型、原生数据结构） | 较慢（解释型） |
| 部署     | 需编译为 `.pyd`/`.so`        | 直接运行       |
| 可维护性 | 较复杂                       | 更简洁         |
| 跨平台   | 需为每个平台编译             | 天然跨平台     |
| 内存管理 | 手动/RAII                    | 自动 GC        |

## 4. 关键实现细节

### 4.1 哈希表查找

C++ 使用 `unordered_map` 和 `unordered_set`，平均 O(1) 查找：

```cpp
// 检查元素是否存在
if (known_set.count(pre_id)) { ... }

// 查找并获取
auto it = name_id_map.find(x);
if (it != name_id_map.end()) {
    return it->second;
}
```

### 4.2 栈操作

C++ 使用 `std::stack`，需要手动清空：

```cpp
// 清空栈
while (!bw_stack.empty()) bw_stack.pop();

// 访问栈顶（引用）
BackwardFrame &top = bw_stack.top();
```

### 4.3 返回多值

C++ 使用 `pair` 和 `tuple`：

```cpp
// 返回两个值
return {result, reasoner_path};

// 返回三个值
return {0, {target_name}, reasoner_path};
```

## 5. 总结

C++ 版与 Python 版的推理逻辑完全一致，主要区别在于：

1. **数据结构**：C++ 使用 STL 容器（`vector`, `unordered_map`, `stack`）
2. **类型系统**：C++ 需要显式声明类型，Python 使用类型提示
3. **内存管理**：C++ 使用值语义和引用，Python 使用对象引用
4. **性能**：C++ 编译后执行效率更高，适合大规模规则库

当前项目已重构为纯 Python 实现，C++ 版本仅作为历史参考。
